# Шпаргалка Python

## Простые объекты

### Числа

```py
None # не определена, не имеет никакого значения

### элементарные операции + - * / идентичны
x = a//b # целое от деления
x = a%b  # остаток от деления
x = a**b # а в степени b 
1e+16 # 1*10 в 16 степени
100 ** 0.5 # заменяет возведение в степень
round(23.456, 2) # 23.46 Округление 

### булевые операции. порядок выполнения: 
not # смена значения
and # булево умножение
or  # булево сложение
== <= >= != # равно, меньше+равно, больше+равно, не равно
a > b > c # Тройное сравнение  b=5; 3 < b < 7 == True

```

### Строки 

```python

### Методы строк 
'sdf  sdf'.split() # разбить строку по пробелам 
'sdf.  sdf'.split('. ') # разделить строку по разделителю. получить список
'.sdf  sdf.'.strip('.') # Убирает лишние символы в начале и в конце  
', '.join(iterator) # Сборка строки из значений любой коллекции через запятую 
'sdfdf "sd" sad' # если нужно вывести кавычки в тексте они должны отличатся от обрамляющих
'er '*3 = 'er er er' # Умножение строки
'АБВ' < 'АБЯ' == False # Сравнение строк происходит посимвольно по коду символа Unicode
'привет'.encode() # decode(<кодировка>) Строку из UTF8 в Unicode 
b'\xd0\xdf\xd1\x80' # строка байт.  b'\xd0\xdf\xd1\x80'.decode('utf8') можно преобразовывать 
len("sdg dgf") # длина строки 
'Тойота RAV4'.find('а') # ==5 # Поиск подстроки в строке
'Тойота RAV4'.rfind('а') # ==5 # С конца строки Поиск подстроки в строке 
'Тойота RAV4'.replace('а', 'б') # замена всех значений в строке
'Тойота RAV4'.upper() # 'ТОЙОТА RAV4' # к верхнему регистру
'Тойота RAV4'.lower() # 'тойота rav4' # к нижнему регистру
'Тойота RAV'.isalpha() # Все ли символы буквы? 
'12345'.isdigit() # Все ли символы цифры?
'Тойота RAV4'.isalnum() # В строке только цифры и буквы? 

### Срезы 
'Привет'[1] # 'p' - второй символа  
'Привет'[-2] # 'е' - Второй с конца
'Привет'[2:4] # 'ив' - С третьего по пятый
'Привет'[2:-1] # 'иве' - с третьего по предпоследний
'Привет'[-3:-1] # 'ве' - с предпоследнего по третий с конца
'Привет'[:4] # 'Прив' - первые четыре  
'Привет'[4:] # 'ет' - С пятого 
'Привет'[::2] # 'Пие' - Брать каждый втоой символ
'Привет'[::-1] # 'тевирП' - Развернуть строку. Брать по одному с конца  

### f-строки
print(f'На улице сейчас {weather}.') 


```

### Переменные

```py
x = y = z = 100 # Множественная инициализация. Все значения равны 100 
x, y, z = 100, 150, 102 # Присвоение сразу трем значениям
type(<переменная>) # определить тип переменной
isinstance(x, int) # Проверка на тип значения int (str, float)
id(x) # идентификатор места хранения переменных. если одинаково значит переменные одни и те же
```

### Преобразования

 - Между системами счисления - схема Горнера
```py
str() # к строке
int() # к целому
float() # к дробному числу
x, y = map(int, input.split()) # map - применяет функцию {1} к каждому значению {2} 

```

### Списки list
```py
list = [2, 4, 6, 8, 10, 12, 14, 16, 18]
len(list) == 9 # длина списка
list[<c>:<по>:<чередуя>] # срез списка. начало с 0. с конца с -1
list.append('sdf') # добавить значение в конец списка
# индексы словаря:
  0         1          2        3
['Ночь', 'Улица', 'Фонарь', 'Аптека']
  -4       -3         -2       -1
list[-1] # получить последний элемент  
list = [x for x in list if x.strip()!=''] # Фильтр пустых строк в списке строк.

### Методы списков
L = [1,2,3,4,5,6]
Срезы аналогичны строкам. (см. Строки)
Сравнение списков аналогично строкам (см. Строки)
[1, 2] * 3 == [1, 2, 1, 2, 1, 2] # Поверхностная копия, ссылаются на первые два элемнта 
5 in [1, 77, 5] == True # Проверка на вхождение элемента
L[0] = "ty" # Заменить первый элемент на "ty"

L.append('123')  # Добавить элемент в список
L.extend([234, 'ewe']) # Расширить список на два указанных элемента, добавить в конец
L + [5, 5, 7] # Расширить список на три указанных элемента
L.insert(2, 'WWW') # Вставка значения на третье место
del L[3] # Удаляет значение из списка по
list.pop() # Используем pop() для удаления последнего элемента и его вывода
L.remove('WWW') # L.remove(4) Удаляет значение из списка по значению или по 
индексу  
reversed(list) # развернуть список с конца 
[5, 5, 7].count(5) == 2 # подсчет количества конкретных значений в списке
min(L) max(L) # получить минимальные и максимальное значения из списка list
L.sort() # сортировка массива 



```

### Словари dict
```py
# Создаем словарь
dict = {'key': 'value'}
# Замена значения по ключу
dict['key'] = 'dict'
# Не может быть двух одинаковых ключей, новые значения заменяют старые
dict['key'] = 'new_value'
# Получение всех ключей и значений
keys = dict.keys()       # список ключей
values = dict.values()    # список значений
# Пример: получение всех значений через запятую
joined_values = ", ".join(dict.values())
print(f"Значения словаря через запятую: {joined_values}")
# Добавление новой пары ключ : значение
dict['голова'] = 'head'
# Удаление пары ключ-значение по ключу с помощью del
del dict['голова']  # Удаляем ключ 'голова'
# Еще один способ удаления — метод pop, который возвращает удаленное значение
removed_value = dict.pop('key', None)  # Удаляем 'key' и возвращаем его значение, если ключ существует
print(f"Удаленное значение: {removed_value}")
# Обход всех ключей и значений словаря
for key, value in dict.items():
    print(f"Ключ: {key}, Значение: {value}")
# Замена значения на основе существующего ключа
dict['новый_ключ'] = 'новое_значение'
dict['новый_ключ'] = 'обновленное_значение'  # Замена значения на новое
# Проверка наличия ключа в словаре
if 'key' in dict:
    print(f"Ключ 'key' есть в словаре")

```

### Кортежи tuple 

```py
Не изменяемые объекты
Нельзя добавлять напрямую
Нельзя удалять 
Можно складывать (3, 4) + ("rf", "go") = (3, 4, "rf", "go")
```

### Множества (сеты) set

```py
# Добавление элемента в множество
s.add('н')  # Добавляем новый элемент
print(s)

# Методы работы с множествами:
set1 = {'Ария', 'Пикник'}
set2 = {'Блестящие', 'Ария'}

# Объединение двух множеств (без повторений)
set_union = set1.union(set2)
print(f"Объединение: {set_union}")

# Разница между множествами (элементы, которые есть в set1, но отсутствуют в set2)
set_difference = set1.difference(set2)
print(f"Разница: {set_difference}")

# Пересечение множеств (элементы, которые есть в обоих множествах)
set_intersection = set1.intersection(set2)
print(f"Пересечение: {set_intersection}")

# Удаление элемента из множества с помощью метода pop, который удаляет и возвращает случайный элемент
removed_element = s.pop()
print(f"Удаленный элемент: {removed_element}")
print(f"Оставшиеся элементы: {s}")

# Еще один способ удаления элемента — discard, который не вызывает ошибку, если элемента нет
s.discard('е')  # Удаляет 'е', если он присутствует
print(s)
```

### Условия 

```py
Ветвления
Логические выражения могут принимать логические значения True («истина») и False («ложь»).

Условный оператор if для записи ветвления «если — то»:

# В переменной beaufort хранится скорость ветра по шкале Бофорта.
if beaufort == 0:
    print('штиль')

Конструкция if-else для записи ветвления «если — то — иначе»:
if beaufort == 0:
    print('штиль')
else:
    print('есть ветер')

Множественное ветвление:
if beaufort == 0:
    print('штиль')
elif beaufort == 1:
    print('тихий ветер')
elif beaufort == 2:
    print('лёгкий ветер')
elif beaufort == 3:
    print('слабый ветер')
elif beaufort == 4:
    print('умеренный ветер')
elif beaufort == 5:
    print('свежий ветер')
elif beaufort == 6:
    print('сильный ветер')

Как только выполняется одно из условий — все следующие elif и else пропускаются.

Логические выражения
Операторы сравнения:
равно ==,
меньше <,
больше >,
больше или равно >=,
меньше или равно <=,
не равно !=.
Логические операторы:

or («или») — логическое сложение:
if beaufort == 7 or beaufort == 8:
    print('крепкий ветер')
and («и») — логическое умножение;
not («не») — отрицание.
```

### Циклы

```py
### for
for iterator in list: # перебор значений коллекций: списков, словарей, сетов
for key, value in dict.items(): # перебор ключей и значений словаря
for key in dict.keys(): # for key in dict   # перебор ключей словаря
for val in dict.values(): # перебор значений словаря
      
range(a, b) # генератор чисел для итерации с a до b-1. Запомнить принцип легко: если на месте a стоит ноль, range(0, N) вернёт ровно N значений
reversed(range(1, 13)) # Обратный отсчет с 12 до 1 
reversed(list) # развернуть список с конца
for i in range(-1, 10): # Перебрать все числа в диапазоне от -1 до 9
    continue # break 
else:
   d=1  # Выполняется один раз после выполнения всего цикла
### while
while a==b: 
else: 
```

Enumerate Она позволяет нам автоматически считать итерации цикла.

```python
my_list = ['яблоко', 'банан', 'вишня', 'персик']

for c, value in enumerate(my_list, 1):
    print(c, value)

# Результат:
# 1 яблоко
# 2 банан
# 3 вишня
# 4 персик

```

```python
for item in list:  # перебор всех элементов списка
    print(item)

for key, value in dict.items():  # перебор ключей и значений словаря
    print(f"Key: {key}, Value: {value}")

for key in dict.keys():  # перебор только ключей словаря
    print(key)

for val in dict.values():  # перебор только значений словаря
    print(val)

range() создаёт последовательность чисел. Его удобно использовать в циклах:


for i in range(1, 5):  # перебор чисел от 1 до 4
    print(i)

for i in range(-1, 10):  # перебор чисел от -1 до 9
    print(i)

reversed() позволяет итерировать коллекции в обратном порядке:

for i in reversed(range(1, 5)):  # обратный отсчет от 4 до 1
    print(i)

list1 = [1, 2, 3]
for i in reversed(list1):  # обратный перебор списка
    print(i)

Оператор continue пропускает текущую итерацию, а break завершает цикл:

for i in range(5):
    if i == 2:
        continue  # пропускаем, когда i равно 2
    print(i)

for i in range(5):
    if i == 3:
        break  # останавливаем цикл, когда i равно 3
    print(i)

Цикл else выполняется, если цикл for завершился без использования break:

for i in range(3):
    print(i)
else:
    print("Цикл завершился без break.")

Циклы while
Цикл while выполняется до тех пор, пока условие истинно. Если условие станет ложным — цикл завершится:

counter = 0
while counter < 5:  # цикл выполняется, пока counter меньше 5
    print(f"Counter: {counter}")
    counter += 1

Цикл else с while работает аналогично, выполняется после завершения цикла:

counter = 0
while counter < 3:
    print(counter)
    counter += 1
else:
    print("Цикл завершён.")

Можно также использовать break в цикле while, чтобы прервать его выполнение:

counter = 0
while True:
    print(counter)
    counter += 1
    if counter == 3:
        break  # завершение цикла, когда counter достигнет 3
pop() можно использовать для удаления элементов из списка в цикле while:

my_list = [1, 2, 3, 4, 5]
while my_list:
    print(my_list.pop())  # удаляет и выводит последний элемент
Этот подход позволяет гибко управлять потоками выполнения программ с помощью циклов for и while.
```
